-- Game class - main game controller
-- Redesigned to use the new entity-based system

local Grid = require("src.core.grid")
local Map = require("src.core.map")
local Player = require("src.entities.player")
local Furniture = require("src.core.furniture")
local Camera = require("src.systems.camera")
local UI = require("src.systems.ui")
local EditorMode = require("src.editor.editorMode")
local SightTweakIntegration = require("src.systems.sight.sightTweakIntegration")

local Game = {}
Game.__index = Game

function Game:new()
    local self = setmetatable({}, Game)
    
    -- Game settings
    self.width = love.graphics.getWidth()
    self.height = love.graphics.getHeight()
    self.tileSize = 64  -- Size of each grid tile in pixels
    
    -- Track window size for responsive layout
    self.lastWidth = self.width
    self.lastHeight = self.height
    
    -- Game state
    self.state = "playing"  -- playing, paused, menu, editor, etc.
    self.debug = false
    
    -- Examination mode state
    self.examinationMode = false
    self.examinationCursor = {
        gridX = 0,
        gridY = 0,
        color = {0.1, 0.1, 0.1, 0.4}, -- Dark background for eye
        eyeColor = {0.9, 0.1, 0.1, 1}, -- Bold red for eye
        borderColor = {0, 0, 0, 1}, -- Bold black border
        metallic = true -- Enable metallic effect
    }
    
    return self
end

function Game:load()
    -- Initialize systems
    self.grid = Grid:new(self.tileSize)
    self.camera = Camera:new(self.width, self.height)
    self.ui = UI:new(self)
    
    -- Load the test map instead of creating the default room
    self:loadTestMap()
    
    -- If test map loading fails, fall back to the default room
    if not self.currentMap then
        -- Create a room map (12x14 grid)
        self.currentMap = Map:new(self.grid, 12, 14)
        
        -- Define window positions (centered on east and south walls)
        local windowPositions = {
            {x = 12, y = 7},  -- East wall, centered
            {x = 6, y = 14}   -- South wall, centered
        }
        
        -- Create the room with windows
        self.currentMap:createRoomMap(windowPositions)
        
        -- Create player in the center of the room
        self.player = Player:new(self.grid, 6, 7)
        
        -- Add furniture to the room
        self:setupRoom()
    end
    
    -- Initialize layout dimensions
    self:initializeLayout()
    
    -- Calculate the appropriate scale for the board to fit in its container
    self:calculateBoardScale()
    
    -- Center camera on player
    self.camera:setTarget(self.player)
    
    -- Initialize editor mode
    self.editorMode = EditorMode:new(self)
    
    -- Initialize sight tweaking UI
    SightTweakIntegration.init(self)
end

function Game:setupRoom()
    -- Create furniture items based on the new 12x14 grid layout
    
    -- Couch in the top right corner
    local couch = Furniture.create("couch", self.grid, 9, 3)
    self.currentMap:addEntity(couch)
    
    -- TV opposite of the couch (across the room)
    local tv = Furniture.create("tv", self.grid, 3, 3)
    self.currentMap:addEntity(tv)
    
    -- Coffee table in front of the sofa
    local coffeeTable = Furniture.create("coffee_table", self.grid, 9, 5, {
        labelText = "coffee table"
    })
    self.currentMap:addEntity(coffeeTable)
    
    -- Cupboard vertically oriented on the left side / west wall
    local cupboard = Furniture.create("cupboard", self.grid, 2, 7, {
        rotation = 0  -- 0 degrees = vertical orientation
    })
    self.currentMap:addEntity(cupboard)
    
    -- Plants for decoration
    local plant1 = Furniture.create("plant", self.grid, 4, 10)
    self.currentMap:addEntity(plant1)
    
    local plant2 = Furniture.create("plant", self.grid, 8, 10)
    self.currentMap:addEntity(plant2)
end

function Game:update(dt)
    if self.state == "playing" then
        -- Update player
        self.player:update(dt)
        
        -- Update map (which updates all entities and tiles)
        self.currentMap:update(dt)
        
        -- Update camera
        self.camera:update(dt)
        
        -- Update zoom notification if active
        if self.zoomNotification then
            self.zoomNotification.timer = self.zoomNotification.timer - dt
            if self.zoomNotification.timer <= 0 then
                self.zoomNotification = nil
            end
        end
    elseif self.state == "editor" then
        -- Update editor mode
        self.editorMode:update(dt)
    end
end

function Game:draw()
    -- Draw minimalist background
    self:drawBackground()
    
    if self.state == "playing" then
        -- Recalculate board scale if window size changes
        if self.lastWidth ~= love.graphics.getWidth() or self.lastHeight ~= love.graphics.getHeight() then
            self.lastWidth = love.graphics.getWidth()
            self.lastHeight = love.graphics.getHeight()
            self:initializeLayout()
            self:calculateBoardScale()
        end
        
        -- Draw board section with game map
        self:drawBoardSection()
        
        -- Draw debug info if enabled
        if self.debug then
            self:drawDebugInfo()
        end
        
        -- Draw sight tweaking UI
        SightTweakIntegration.draw()
        
        -- Draw zoom notification if active
        if self.zoomNotification then
            love.graphics.setColor(1, 1, 1, 0.7)
            love.graphics.setFont(love.graphics.newFont("assets/fonts/Tomorrow/Tomorrow-Bold.ttf", 16))
            local textWidth = love.graphics.getFont():getWidth(self.zoomNotification.text)
            love.graphics.print(
                self.zoomNotification.text,
                self.layout.board.x + (self.layout.board.width - textWidth) / 2,
                self.layout.board.y + 40
            )
        end
    elseif self.state == "editor" then
        -- Draw editor mode
        self.editorMode:draw()
    end
end

function Game:initializeLayout()
    -- Calculate layout dimensions
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    
    self.layout = {
        -- Keep only the board section (main game area) with the same dimensions
        board = {
            x = 20,
            y = 100,
            width = screenWidth * 0.7 - 30,
            height = screenHeight - 180
        }
    }
end

function Game:drawBackground()
    -- Draw minimalist background
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    
    -- Update layout if window size changes
    if screenWidth ~= self.lastWidth or screenHeight ~= self.lastHeight then
        self.lastWidth = screenWidth
        self.lastHeight = screenHeight
        self:initializeLayout()
    end
    
    -- Draw plain background with #eeeeee color
    love.graphics.setColor(238/255, 238/255, 238/255, 1) -- #eeeeee in RGB
    love.graphics.rectangle("fill", 0, 0, screenWidth, screenHeight)
    
    -- Reset color
    love.graphics.setColor(1, 1, 1, 1)
end

function Game:drawBoardSection()
    -- Apply clipping to ensure the board stays within its container
    love.graphics.setScissor(
        self.layout.board.x, 
        self.layout.board.y, 
        self.layout.board.width, 
        self.layout.board.height
    )
    
    -- Reset color for the map drawing
    love.graphics.setColor(1, 1, 1, 1)
    
    -- Draw the map
    self.camera:attach()
    self.currentMap:draw()
    
    -- Draw the board grid if debug mode is enabled
    if self.debug then
        self:drawBoardFrame()
    end
    
    -- Draw examination cursor if in examination mode
    if self.examinationMode then
        self:drawExaminationCursor()
    end
    
    self.camera:detach()
    
    -- Reset scissor
    love.graphics.setScissor()
    
    -- Display zoom level indicator if not at default zoom
    if math.abs(self.camera.scale - 1.0) > 0.01 then
        love.graphics.setColor(0.2, 0.2, 0.2, 0.7)
        love.graphics.setFont(love.graphics.newFont("assets/fonts/Tomorrow/Tomorrow-Regular.ttf", 12))
        love.graphics.print(string.format("Zoom: %.2fx", self.camera.scale), 
                          self.layout.board.x + 10, 
                          self.layout.board.y + self.layout.board.height - 30)
    end
    
    -- Reset color
    love.graphics.setColor(1, 1, 1, 1)
end

function Game:drawBoardFrame()
    if not self.currentMap then return end
    
    local mapWidth = self.currentMap.width * self.grid.tileSize
    local mapHeight = self.currentMap.height * self.grid.tileSize
    
    -- Draw subtle grid lines for the board
    love.graphics.setColor(0.85, 0.83, 0.8, 0.5) -- Light gray for grid lines
    love.graphics.setLineWidth(0.5)
    
    -- Draw vertical grid lines
    for x = 0, mapWidth, self.grid.tileSize do
        love.graphics.line(x, 0, x, mapHeight)
    end
    
    -- Draw horizontal grid lines
    for y = 0, mapHeight, self.grid.tileSize do
        love.graphics.line(0, y, mapWidth, y)
    end
    
    -- Reset color and line width
    love.graphics.setLineWidth(1)
end

function Game:drawExaminationCursor()
    if not self.examinationMode then return end
    
    local x = self.examinationCursor.gridX * self.grid.tileSize
    local y = self.examinationCursor.gridY * self.grid.tileSize
    local size = self.grid.tileSize
    
    -- Draw cursor background
    love.graphics.setColor(self.examinationCursor.color)
    love.graphics.rectangle("fill", x, y, size, size)
    
    -- Draw eye symbol
    love.graphics.setColor(self.examinationCursor.eyeColor)
    
    -- Eye shape (circle)
    local eyeSize = size * 0.5
    local eyeX = x + (size - eyeSize) / 2
    local eyeY = y + (size - eyeSize) / 2
    
    love.graphics.circle("fill", eyeX + eyeSize/2, eyeY + eyeSize/2, eyeSize/2)
    
    -- Pupil
    love.graphics.setColor(0, 0, 0, 1)
    love.graphics.circle("fill", eyeX + eyeSize/2, eyeY + eyeSize/2, eyeSize/5)
    
    -- Border
    love.graphics.setColor(self.examinationCursor.borderColor)
    love.graphics.setLineWidth(2)
    love.graphics.rectangle("line", x, y, size, size)
    
    -- Reset
    love.graphics.setLineWidth(1)
    love.graphics.setColor(1, 1, 1, 1)
end

function Game:drawDebugInfo()
    -- Draw debug information
    love.graphics.setColor(1, 1, 1, 0.8)
    love.graphics.setFont(love.graphics.newFont("assets/fonts/Tomorrow/Tomorrow-Regular.ttf", 12))
    
    local debugY = 10
    love.graphics.print("FPS: " .. love.timer.getFPS(), 10, debugY)
    debugY = debugY + 20
    
    love.graphics.print("Player: " .. self.player.gridX .. ", " .. self.player.gridY, 10, debugY)
    debugY = debugY + 20
    
    if self.camera.target then
        love.graphics.print("Camera Target: " .. self.camera.target.gridX .. ", " .. self.camera.target.gridY, 10, debugY)
    end
    
    -- Reset color
    love.graphics.setColor(1, 1, 1, 1)
end

function Game:keypressed(key)
    -- Debug output for key presses
    print("Game keypressed: " .. key)
    
    -- Check if sight tweaking UI handles the key press
    if key == "f7" then
        print("F7 key detected in Game:keypressed")
        if SightTweakIntegration.ui then
            print("SightTweakIntegration.ui exists, toggling visibility")
            SightTweakIntegration.ui:toggle()
            return
        else
            print("SightTweakIntegration.ui does not exist, reinitializing")
            SightTweakIntegration.init(self)
            if SightTweakIntegration.ui then
                print("Reinitialization successful, toggling visibility")
                SightTweakIntegration.ui:toggle()
                return
            end
        end
    end
    
    -- Toggle editor mode with F2
    if key == "f2" then
        if self.state == "editor" then
            self.editorMode:closeEditor()
        else
            self.editorMode:launchEditor()
        end
        return
    end
    
    if self.state == "playing" then
        -- Check if shift is being held (for direction change)
        local isShiftHeld = love.keyboard.isDown("lshift") or love.keyboard.isDown("rshift")
        
        -- If in examination mode
        if self.examinationMode then
            -- Movement controls for examination cursor
            local dx, dy = 0, 0
            
            if key == "up" or key == "w" then
                dy = -1
            elseif key == "down" or key == "s" then
                dy = 1
            elseif key == "left" or key == "a" then
                dx = -1
            elseif key == "right" or key == "d" then
                dx = 1
            end
            
            if dx ~= 0 or dy ~= 0 then
                -- Move the examination cursor
                self.examinationCursor.gridX = self.examinationCursor.gridX + dx
                self.examinationCursor.gridY = self.examinationCursor.gridY + dy
            end
            
            -- Exit examination mode with X key
            if key == "x" then
                self:toggleExaminationMode()
            end
            
            -- Also exit with escape key
            if key == "escape" then
                self:toggleExaminationMode()
            end
        else
            -- Normal gameplay mode
            -- Movement controls for player
            local dx, dy = 0, 0
            
            if key == "up" or key == "w" then
                dy = -1
            elseif key == "down" or key == "s" then
                dy = 1
            elseif key == "left" or key == "a" then
                dx = -1
            elseif key == "right" or key == "d" then
                dx = 1
            end
            
            if dx ~= 0 or dy ~= 0 then
                if isShiftHeld then
                    -- Change direction without moving (costs 25 TU)
                    local newDirection = nil
                    
                    if dx == 1 and dy == 0 then
                        newDirection = 0     -- East
                    elseif dx == 0 and dy == 1 then
                        newDirection = 1     -- South
                    elseif dx == -1 and dy == 0 then
                        newDirection = 2     -- West
                    elseif dx == 0 and dy == -1 then
                        newDirection = 3     -- North
                    end
                    
                    if newDirection ~= nil and self.player.facingDirection ~= newDirection then
                        print("Changing direction to " .. newDirection)
                        
                        -- Use the time system if available
                        if self.timeManager then
                            -- Create a direction change action (costs 25 TU)
                            local action = self.actionSystem:createDirectionChangeAction(
                                self.player, newDirection
                            )
                            self.timeManager:queueAction(action)
                        else
                            -- Fallback if time system not available
                            self.player:changeDirection(newDirection)
                        end
                    end
                else
                    -- Normal movement (costs 25 TU)
                    if self.timeManager then
                        -- Create a move action (costs 25 TU)
                        local action = self.actionSystem:createMoveAction(self.player, dx, dy)
                        self.timeManager:queueAction(action)
                    else
                        -- Fallback to direct movement if time system not available
                        self.player:move(dx, dy)
                    end
                end
            end
            
            -- Toggle debug mode
            if key == "f1" then
                self.debug = not self.debug
            end
            
            -- Interaction key
            if key == "e" or key == "space" then
                -- Interact with the tile in front of the player
                self.player:interact()
            end
            
            -- Examination mode (X key)
            if key == "x" then
                self:toggleExaminationMode()
            end
            
            -- Handle preset zoom levels with Z + number keys
            if key == "z" then
                self.zKeyPressed = true
            elseif self.zKeyPressed and tonumber(key) then
                local zoomLevel = tonumber(key) * 0.25
                if zoomLevel > 0 then
                    self.camera:setZoom(zoomLevel)
                    
                    -- Show zoom notification
                    self.zoomNotification = {
                        text = string.format("Zoom: %.2fx", zoomLevel),
                        timer = 1.5  -- Show for 1.5 seconds
                    }
                end
            end
        end
    elseif self.state == "editor" then
        -- Pass keypresses to the editor
        self.editorMode:keypressed(key)
    end
end

function Game:keyreleased(key)
    if key == "z" then
        self.zKeyPressed = false
    end
    
    -- Handle key releases if needed
end

function Game:mousepressed(x, y, button)
    -- Check if sight tweaking UI handles the mouse press
    if SightTweakIntegration.handleMousePressed(x, y, button) then
        return
    end
    
    if self.state == "playing" then
        -- Handle middle mouse button for panning
        if button == 3 then
            self.camera:startPan(x, y)
            return
        end
        
        -- Convert screen coordinates to world coordinates
        local worldX, worldY = self.camera:screenToWorld(x, y)
        
        -- Convert world coordinates to grid coordinates
        local gridX, gridY = self.grid:worldToGrid(worldX, worldY)
        
        if button == 1 then  -- Left click
            -- Example: Select a tile or move to it
            print("Grid clicked: " .. gridX .. ", " .. gridY)
        end
    elseif self.state == "editor" then
        -- Pass mouse events to the editor
        self.editorMode:mousepressed(x, y, button)
    end
end

function Game:mousereleased(x, y, button)
    -- Check if sight tweaking UI handles the mouse release
    if SightTweakIntegration.handleMouseReleased(x, y, button) then
        return
    end
    
    if self.state == "playing" then
        -- Stop panning when middle mouse button is released
        if button == 3 then
            self.camera:stopPan()
            return
        end
    elseif self.state == "editor" then
        -- Pass mouse events to the editor
        self.editorMode:mousereleased(x, y, button)
    end
end

function Game:wheelmoved(x, y)
    if self.state == "editor" then
        self.editorMode:wheelmoved(x, y)
    else
        -- Handle zooming in normal gameplay
        local mouseX, mouseY = love.mouse.getPosition()
        self.camera:zoomAt(mouseX, mouseY, y)
    end
end

function Game:mousemoved(x, y, dx, dy)
    -- Check if sight tweaking UI handles the mouse movement
    if SightTweakIntegration.handleMouseMoved(x, y, dx, dy) then
        return
    end
    
    if self.state == "playing" then
        -- Update camera panning if active
        self.camera:updatePan(x, y)
    elseif self.state == "editor" then
        -- Pass mouse movement to editor if needed
        -- self.editorMode:mousemoved(x, y, dx, dy)
    end
end

function Game:textinput(text)
    if self.state == "editor" then
        -- Pass text input to editor
        self.editorMode:textinput(text)
    end
end

function Game:toggleExaminationMode()
    self.examinationMode = not self.examinationMode
    
    if self.examinationMode then
        -- Initialize examination cursor at player position
        self.examinationCursor.gridX = self.player.gridX
        self.examinationCursor.gridY = self.player.gridY
    end
end

function Game:loadTestMap()
    -- Load the test map module
    local TestMap = require("src.maps.testMap")
    
    -- Create the test map
    self.currentMap = TestMap.create(self.grid)
    self.player = self.currentMap.player
    
    print("Test map loaded successfully")
    return true
end

function Game:loadMap(mapName)
    if not mapName then return end
    
    -- Sanitize map name for filename
    local safeMapName = mapName:gsub("[^%w_%-%.]" , "_")
    if safeMapName == "" then safeMapName = "custom_map" end
    
    -- Load from file
    local filename = "maps/" .. safeMapName .. ".json"
    
    if not love.filesystem.getInfo(filename) then
        print("No saved map found: " .. filename)
        return
    end
    
    local mapJson, size = love.filesystem.read(filename)
    
    if not mapJson then
        print("Failed to read map file: " .. filename)
        return
    end
    
    -- Parse JSON
    local json = require("lib.json")
    local mapData = json.decode(mapJson)
    
    if not mapData then
        print("Failed to parse map data")
        return
    end
    
    -- Create a new map with the loaded dimensions
    local width = mapData.width or 12
    local height = mapData.height or 14
    self.currentMap = Map:new(self.grid, width, height)
    
    -- Load tiles
    if mapData.tiles then
        for y = 1, height do
            for x = 1, width do
                local index = (y - 1) * width + x
                local tileData = mapData.tiles[index]
                
                if tileData then
                    if tileData.type == "wall" and tileData.isWindow then
                        self.currentMap:setTile(x, y, "wall", {isWindow = true})
                    else
                        self.currentMap:setTile(x, y, tileData.type)
                    end
                else
                    -- Default to floor if no tile data
                    self.currentMap:setTile(x, y, "floor")
                end
            end
        end
    end
    
    -- Load entities
    if mapData.entities then
        for _, entityData in ipairs(mapData.entities) do
            local entity = Furniture.create(entityData.type, self.grid, entityData.x, entityData.y)
            if entity then
                self.currentMap:addEntity(entity)
            end
        end
    end
    
    -- Recalculate board scale
    self:calculateBoardScale()
    
    print("Map loaded from " .. filename)
end

function Game:calculateBoardScale()
    -- Calculate the total map size in pixels
    local mapWidth = self.currentMap.width * self.grid.tileSize
    local mapHeight = self.currentMap.height * self.grid.tileSize
    
    -- Calculate the available space in the board section (with some padding)
    local availableWidth = self.layout.board.width - 40
    local availableHeight = self.layout.board.height - 40
    
    -- Calculate the scale needed to fit the map in the available space
    local scaleX = availableWidth / mapWidth
    local scaleY = availableHeight / mapHeight
    
    -- Use the smaller scale to ensure the entire map fits
    local scale = math.min(scaleX, scaleY, 1.0) -- Cap at 1.0 to avoid enlarging small maps
    
    -- Update the camera scale
    self.camera.scale = scale
    
    -- Center the map in the available space
    local centeredX = (self.layout.board.width - (mapWidth * scale)) / 2
    local centeredY = (self.layout.board.height - (mapHeight * scale)) / 2
    
    -- Update the camera's board viewport with the centered position
    self.camera:setBoardViewport(
        self.layout.board.x + centeredX,
        self.layout.board.y + centeredY,
        mapWidth * scale,
        mapHeight * scale
    )
    
    -- Adjust the grid tile size based on the scale
    self.grid.scaledTileSize = self.grid.tileSize * scale
end

return Game
